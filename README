# Raft Implementation (Work in Progress)
This branch contains the experimental development of:
- WAL storage layer
- Snapshot mechanism
- FSM apply pipeline
- Log structure and monotonic indexes

Not production-ready. Actively being designed and tested.



Raft-Based Key-Value Store (Go)

This project is a distributed key-value store built from scratch using the Raft consensus algorithm.  
It implements a custom Write-Ahead Log (WAL) for durability and prepares the foundation for an upcoming Finite State Machine (FSM) and RPC communication layer.  
All components are written in Go with a strong focus on reliability, fault-tolerance, and modularity.

---

## Current Functionalities

 **Write-Ahead Log (WAL)**  
- Appends, reads, and persists log entries to disk.  
- Supports sequential recovery and integrity validation.  
- Designed for monotonic log index growth (simplifies recovery and snapshotting).  

 **Raft Core Setup (Initial)**  
- Log entry handling integrated with WAL.  
- Placeholder hooks for FSM application and snapshot logic.  
- Prepares the structure for leader election and replication.

 **Planned Next Steps**  
- Implement FSM (`fsm/apply.go`, `fsm/snapshot.go`) for applying commands (PUT, DELETE, GET, ...).  
- Introduce periodic snapshotting for recovery beyond WAL.  
- Add RPC layer for node communication and log synchronization.  

---

## Running Tests

You can run all test suites (unit + integration) using:

```bash
go test ./... -v


## Technical

### Read Consistency 

The system currently supports follower-based read operations for performance.
Follower reads are correct but not linearizable. This means:

- All followers apply only committed Raft log entries (state is always valid).
- However, followers may temporarily lag behind the leader.
- A GET issued to a follower may return a slightly outdated value (stale read).

Leader reads are fully linearizable. Follower reads provide higher throughput
but do not guarantee that the returned value reflects the most recent write.

### Client Request Routing & Redirect Response Model

This KV-store uses a Redirect Response Model to route client requests efficiently and consistently across the Raft cluster.
This model is a widely-used industry standard, employed by systems such as Etcd, Consul.

The goals of this design are:

Low-latency reads by allowing followers to serve GET requests

Strong consistency for writes by ensuring PUT/DELETE/CAS/BATCH operations are handled only by the current leader

Simple and transparent failover through automatic client-side redirection

Clear separation between internal Raft communication and external client API




## Acknowledgements

The WAL (Write-Ahead Log) component of this project was inspired by [tidwall/wal](https://github.com/tidwall/wal) by Josh Baker.
The design and structure of the WAL implementation in this repository follow similar concepts for educational purposes.
